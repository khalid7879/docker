name: CI/CD for PHP App

on:
  push:
    branches:
      - main  # Trigger pipeline on push to main
jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build and Push Docker Images
        run: |
          # Build Nginx image
          docker build -t ${{ secrets.DOCKER_USERNAME }}/php-nginx -f Dockerfile .
          docker push ${{ secrets.DOCKER_USERNAME }}/php-nginx
          # Build PHP (web) image
          docker build -t ${{ secrets.DOCKER_USERNAME }}/php-web -f php.Dockerfile .
          docker push ${{ secrets.DOCKER_USERNAME }}/php-web
  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Deploy to AWS EC2
        run: |
          echo "${{ secrets.AWS_KEY }}" > private_key.pem
          chmod 600 private_key.pem
          scp -o StrictHostKeyChecking=no -i private_key.pem database.sql ${{ secrets.AWS_USER }}@${{ secrets.AWS_HOST }}:/home/ubuntu/app/database.sql
          ssh -o StrictHostKeyChecking=no -i private_key.pem ${{ secrets.AWS_USER }}@${{ secrets.AWS_HOST }} << 'EOF'
            set -euo pipefail

            # login to Docker Hub (for private images)
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin || true

            # Ensure network and app dir
            docker network create app_network || true
            mkdir -p /home/ubuntu/app

            # Stop & remove existing containers
            docker rm -f php-nginx php-web mysql-db || true

            # Pull latest images
            echo "DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}"
            echo "Running command: docker pull ${{ secrets.DOCKER_USERNAME }}/php-web || true"
            docker pull ${{ secrets.DOCKER_USERNAME }}/php-web || true
            echo "Running command: docker pull ${{ secrets.DOCKER_USERNAME }}/php-nginx || true"
            docker pull ${{ secrets.DOCKER_USERNAME }}/php-nginx || true

            # Run MySQL (if not already)
            docker run -d --name mysql-db --network app_network 
              -v /home/ubuntu/app/database.sql:/docker-entrypoint-initdb.d/database.sql 
              -e MYSQL_ROOT_PASSWORD=pass@321 
              -e MYSQL_DATABASE=student_enrollment 
              -p 3306:3306 
              --restart unless-stopped 
              mysql:8.0 || true

            echo "Waiting for MySQL to initialize..."
            sleep 20

            # Run PHP (web)
            docker run -d --name php-web --network app_network \
              -e DB_HOST=mysql-db -e DB_USER=root -e DB_PASSWORD=pass@321 -e DB_NAME=student_enrollment \
              --restart unless-stopped \
              ${{ secrets.DOCKER_USERNAME }}/php-web

            # Run Nginx
            docker run -d --name php-nginx --network app_network \
              -p 80:80 \
              --restart unless-stopped \
              ${{ secrets.DOCKER_USERNAME }}/php-nginx || true

            # Wait a few seconds, then check status
            sleep 5
            echo "Container status:"
            docker ps -a --filter "name=php-nginx" --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"

            status=$(docker inspect --format '{{.State.Status}}' php-nginx 2>/dev/null || echo "missing")
            echo "php-nginx state: $status"

            if [ "$status" != "running" ]; then
              echo "php-nginx logs (last 200 lines):"
              docker logs php-nginx --tail 200 || true
              echo "Inspect output:"
              docker inspect php-nginx || true
              exit 1
            fi

            echo "php-nginx is running"
          EOF